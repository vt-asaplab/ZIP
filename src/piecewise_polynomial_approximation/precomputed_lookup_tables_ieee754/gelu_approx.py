import torch
import torch.nn as nn

intervals = [-5.0, -2.5, -0.15625, 0.0, 0.01953125, 1.25, 2.5, 5.0]
coefficients = [[1.2895795981968639, 4.073032947276732, 4.691033381289938, 2.8792384754199603, 1.0791053866767202, 0.26086661593687743, 0.04108705962946128, 0.004090063940276508, 0.0002343885865897584, 5.906040360350348e-06], [2.3769643341185635e-05, 0.5004288463693298, 0.40197966473107627, 0.01115437345589627, -0.04298357850783698, 0.03138001708831284, 0.03609092122290339, 0.012964912260609118, 0.0021511620865338975, 0.0001413321509835783], [0.0, 0.5000472940548409, 0.40086153469152797, 0.020747805925987493, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [-0.0, 0.4999999066695583, 0.3989725449094174, -0.00260987456515885, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.1533207545196004e-08, 0.49999750610410104, 0.39899539584206717, -0.0004493976605051402, -0.06493564785740369, -0.004367996594786167, 0.016032685786778147, -0.004354770904526548, 0.00027420682916810655, 0.0], [-0.013522253137682405, 0.5726799413735915, 0.22874981584958923, 0.2250313045965364, -0.24696704855655705, 0.08426913292378585, -0.006936731001546747, -0.002835397688920425, 0.0007817716865583544, -6.031440654420408e-05], [1.2895796332067166, -3.0730330363365477, 4.691033481601212, -2.8792385410877976, 1.0791054142130794, -0.2608666236066401, 0.04108706104825214, -0.004090064108324079, 0.00023438859815134666, -5.906040712281196e-06]]

def approx_gelu(x: torch.Tensor) -> torch.Tensor:
    out = torch.empty_like(x)

    def poly_eval(z: torch.Tensor, coeffs):
        # Evaluate the polynomial sum of coeffs[k] * z^k
        result = torch.zeros_like(z)
        for power, c in enumerate(coeffs):
            result += c * (z ** power)
        return result

    num_intervals = len(intervals)
    for i in range(num_intervals - 1):
        lower = intervals[i]
        upper = intervals[i + 1]
        mask = (x >= lower) & (x < upper)
        out[mask] = poly_eval(x[mask], coefficients[i])

    # Values >= the last boundary
    mask_last = (x >= intervals[-1])
    out[mask_last] = poly_eval(x[mask_last], coefficients[-1])

    # Values < the first boundary
    mask_first = (x < intervals[0])
    out[mask_first] = poly_eval(x[mask_first], coefficients[0])

    return out
