import torch
import torch.nn as nn

intervals = [-8.0, -4.5, -1.0, -0.125, 0.75, 2.5, 6.0, 9.5, 13.0, 16.5, 20.0]
coefficients = [[0.6035785124771123, 0.439610099004231, 0.13863126752310165, 0.024039858753371657, 0.0024016282349247336, 0.00013033879843153454, 2.988879391423172e-06], [0.9901374270932756, 0.9654058281370521, 0.44962328581512717, 0.1265209684147536, 0.02218423501096273, 0.0022376882880160475, 9.897809189881897e-05], [0.9999995155106757, 0.999990027355221, 0.49992155305332897, 0.16635613305630698, 0.04098309950789815, 0.0074753574528120155, 0.0007967909638794108], [1.0002521633266752, 0.9985649636471617, 0.48100109936120594, 0.23054462141617774, 0.0, 0.0, 0.0], [1.0144935811850266, 0.927271356501063, 0.6499112760321908, 0.0027042513102301362, 0.14364583017107646, -0.026984528637981245, 0.007248548741478116], [183.51082001159307, -312.76975282484324, 224.01275810210495, -84.6162816069368, 18.21950987464243, -2.1048684415614973, 0.10854265753383023], [387099.6358231683, -332363.70677797723, 119162.73417758264, -22869.899791456137, 2483.6397206898896, -145.1868921447562, 3.5944391611639395], [147238804.93372887, -84549663.69084738, 20272747.805543423, -2599843.8523459607, 188257.6527495626, -7307.590568380416, 119.03147724137114], [27660655120.36178, -11926444968.62207, 2146182902.2344303, -206398689.4172846, 11193437.480372965, -324771.570468326, 3941.781183849752], [3523511698050.265, -1215689880193.243, 174988846316.9165, -13453861267.325468, 582873090.0313679, -13496168.462323245, 130533.86495722926]]

def approx_softmax(x: torch.Tensor) -> torch.Tensor:
    out = torch.empty_like(x)

    def poly_eval(z: torch.Tensor, coeffs):
        # Evaluate the polynomial sum of coeffs[k] * z^k
        result = torch.zeros_like(z)
        for power, c in enumerate(coeffs):
            result += c * (z ** power)
        return result

    num_intervals = len(intervals)
    for i in range(num_intervals - 1):
        lower = intervals[i]
        upper = intervals[i + 1]
        mask = (x >= lower) & (x < upper)
        out[mask] = poly_eval(x[mask], coefficients[i])

    # Values >= the last boundary
    mask_last = (x >= intervals[-1])
    out[mask_last] = poly_eval(x[mask_last], coefficients[-1])

    # Values < the first boundary
    mask_first = (x < intervals[0])
    out[mask_first] = poly_eval(x[mask_first], coefficients[0])

    return out
